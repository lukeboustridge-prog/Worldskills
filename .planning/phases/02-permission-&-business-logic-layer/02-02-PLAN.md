---
phase: 02-permission-business-logic
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/(dashboard)/management-meeting-actions.ts
  - src/lib/meeting-queries.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create a management meeting via server action"
    - "Secretariat can create a management meeting via server action"
    - "Management meeting creation sends emails to all SAs and selected Secretariat"
    - "SA can retrieve all management meetings plus their skill meetings"
    - "Secretariat member can retrieve only management meetings they're invited to"
    - "Management meeting can be updated (minutes, action points)"
    - "Management meeting can be deleted by Admin or Secretariat"
    - "Documents can be attached to management meetings"
    - "External links can be added to management meetings"
    - "UI can query available Secretariat members for attendee selection"
  artifacts:
    - path: "src/app/(dashboard)/management-meeting-actions.ts"
      provides: "Server actions for management meeting CRUD"
      exports: ["createManagementMeetingAction", "updateManagementMeetingMinutesAction", "deleteManagementMeetingAction", "addManagementMeetingDocumentAction", "deleteManagementMeetingDocumentAction", "addManagementMeetingLinkAction", "removeManagementMeetingLinkAction"]
    - path: "src/lib/meeting-queries.ts"
      provides: "Meeting retrieval functions by role and Secretariat member lookup"
      exports: ["getMeetingsForUser", "getSecretariatMembers", "isManagementMeeting"]
  key_links:
    - from: "src/app/(dashboard)/management-meeting-actions.ts"
      to: "src/lib/permissions/meeting.ts"
      via: "Permission checks before mutations"
      pattern: "canCreateManagementMeeting|canManageMeeting"
    - from: "src/app/(dashboard)/management-meeting-actions.ts"
      to: "src/lib/email/meeting-invitation.ts"
      via: "Send invitations after creation"
      pattern: "sendMeetingInvitation"
    - from: "src/app/(dashboard)/management-meeting-actions.ts"
      to: "src/lib/activity.ts"
      via: "Log management meeting activities"
      pattern: "logActivity.*skillId.*null"
    - from: "src/lib/meeting-queries.ts"
      to: "prisma.meeting.findMany"
      via: "Database queries with role-based filtering"
      pattern: "prisma\\.meeting\\.findMany"
    - from: "src/lib/meeting-queries.ts"
      to: "prisma.user.findMany"
      via: "Query Secretariat members for attendee selection"
      pattern: "prisma\\.user\\.findMany.*Secretariat"
---

<objective>
Create server actions for management meeting CRUD operations and meeting visibility queries that respect role-based access control.

Purpose: Implements AUTH-01 to AUTH-06 (authorization), MEET-01 to MEET-08 (meeting management), EMAIL-01 to EMAIL-03 (calendar invites). This plan wires together the permission helpers, email templates, and activity logging from Plan 02-01.

Output: Server actions that enforce authorization rules and a unified meeting query function that returns appropriate meetings based on user role, plus a helper to query available Secretariat members.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-permission-&-business-logic-layer/02-RESEARCH.md
@.planning/phases/02-permission-&-business-logic-layer/02-01-SUMMARY.md

# Existing patterns to follow
@src/app/(dashboard)/skills/[skillId]/meeting-actions.ts
@src/lib/auth.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create and update management meeting actions</name>
  <files>src/app/(dashboard)/management-meeting-actions.ts</files>
  <action>
Create new file `src/app/(dashboard)/management-meeting-actions.ts` with "use server" directive.

**Imports:**
```typescript
"use server";

import { Role, Prisma } from "@prisma/client";
import { revalidatePath } from "next/cache";
import { z } from "zod";

import { logActivity } from "@/lib/activity";
import { requireUser } from "@/lib/auth";
import { sendMeetingInvitation } from "@/lib/email/meeting-invitation";
import { canCreateManagementMeeting, canManageMeeting } from "@/lib/permissions/meeting";
import { prisma } from "@/lib/prisma";
```

**Copy helper functions from meeting-actions.ts:**
- `createId()` - generates unique IDs
- `MeetingDocument` interface
- `MeetingLink` interface
- `normaliseMeetingDocuments()`
- `normaliseMeetingLinks()`
- `serialiseMeetingDocuments()`
- `serialiseMeetingLinks()`
- `parseInitialDocuments()`
- `parseInitialLinks()`

**1. createManagementMeetingAction(formData: FormData)**

Schema (Zod):
```typescript
const createManagementMeetingSchema = z.object({
  title: z.string().min(2, "Title must be at least 2 characters"),
  startTime: z.string().refine((val) => !Number.isNaN(Date.parse(val)), {
    message: "Invalid start time"
  }),
  endTime: z.string().refine((val) => !Number.isNaN(Date.parse(val)), {
    message: "Invalid end time"
  }),
  meetingLink: z.string().url().optional().or(z.literal("")),
  secretariatAttendeeIds: z.string(), // JSON array of user IDs
  initialDocuments: z.string().optional(),
  initialLinks: z.string().optional()
});
```

Logic:
1. `const user = await requireUser()`
2. `if (!canCreateManagementMeeting(user)) throw new Error("Only Admins and Secretariat can create management meetings")`
3. Validate with `createManagementMeetingSchema.safeParse()`
4. Validate endTime > startTime
5. Parse secretariatAttendeeIds: `JSON.parse(parsed.data.secretariatAttendeeIds) as string[]`
6. Fetch all SAs: `prisma.user.findMany({ where: { role: Role.SA } })`
7. Fetch selected Secretariat members: `prisma.user.findMany({ where: { id: { in: secretariatAttendeeIds }, role: Role.Secretariat } })`
8. Parse initial documents and links using helper functions
9. Create meeting with `skillId: null`:
   ```typescript
   const meeting = await prisma.meeting.create({
     data: {
       skillId: null,
       title: parsed.data.title,
       startTime,
       endTime,
       meetingLink: parsed.data.meetingLink || null,
       documents: serialiseMeetingDocuments(initialDocuments),
       links: serialiseMeetingLinks(initialLinks)
     }
   });
   ```
10. Create MeetingAttendee records for selected Secretariat members ONLY:
    ```typescript
    if (secretariatAttendeeIds.length > 0) {
      await prisma.meetingAttendee.createMany({
        data: secretariatAttendeeIds.map((userId) => ({
          meetingId: meeting.id,
          userId
        }))
      });
    }
    ```
11. Send email to all SAs + selected Secretariat:
    ```typescript
    const recipientEmails: string[] = [
      ...allSAs.map(sa => sa.email),
      ...selectedSecretariat.map(s => s.email)
    ].filter(Boolean);

    if (recipientEmails.length > 0) {
      await sendMeetingInvitation({
        to: recipientEmails,
        meeting: {
          title: meeting.title,
          startTime: meeting.startTime,
          endTime: meeting.endTime,
          meetingLink: meeting.meetingLink,
          skillName: null,
          meetingType: "management"
        }
      });
    }
    ```
12. Log activity: `logActivity({ skillId: null, userId: user.id, action: "ManagementMeetingCreated", payload: { meetingId: meeting.id, title: meeting.title, attendeeCount: secretariatAttendeeIds.length } })`
13. Revalidate paths: `revalidatePath("/meetings")` and `revalidatePath("/hub/meetings")`
14. Return `{ success: true, meetingId: meeting.id }`

**2. updateManagementMeetingMinutesAction(formData: FormData)**

Schema:
```typescript
const updateManagementMeetingMinutesSchema = z.object({
  meetingId: z.string().min(1),
  minutes: z.string().optional(),
  actionPoints: z.string().optional()
});
```

Logic:
1. `const user = await requireUser()`
2. Validate with schema
3. Fetch meeting: `prisma.meeting.findUnique({ where: { id: parsed.data.meetingId } })`
4. Check meeting exists and `meeting.skillId === null` (must be management meeting)
5. `if (!canManageMeeting(user, meeting)) throw new Error("Only Admins and Secretariat can update management meeting minutes")`
6. Update meeting:
   ```typescript
   await prisma.meeting.update({
     where: { id: parsed.data.meetingId },
     data: {
       minutes: parsed.data.minutes || null,
       actionPoints: parsed.data.actionPoints || null
     }
   });
   ```
7. Log activity: `logActivity({ skillId: null, userId: user.id, action: "ManagementMeetingMinutesUpdated", payload: { meetingId: meeting.id, title: meeting.title } })`
8. Revalidate paths
9. Return `{ success: true }`
  </action>
  <verify>
Run: `npx tsc --noEmit`
Check: File exists at src/app/(dashboard)/management-meeting-actions.ts
Check: Exports createManagementMeetingAction and updateManagementMeetingMinutesAction
  </verify>
  <done>
Create and update minutes actions implemented with Zod validation, permission checks, email sending, and activity logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add delete management meeting action</name>
  <files>src/app/(dashboard)/management-meeting-actions.ts</files>
  <action>
Add deleteManagementMeetingAction to the file created in Task 1.

**deleteManagementMeetingAction(formData: FormData)**

Schema:
```typescript
const deleteManagementMeetingSchema = z.object({
  meetingId: z.string().min(1)
});
```

Logic:
1. `const user = await requireUser()`
2. Validate with schema
3. Fetch meeting with documents for cleanup:
   ```typescript
   const meeting = await prisma.meeting.findUnique({
     where: { id: parsed.data.meetingId }
   });
   ```
4. Check meeting exists: `if (!meeting) throw new Error("Meeting not found")`
5. Check is management meeting: `if (meeting.skillId !== null) throw new Error("This action is only for management meetings")`
6. Check permission: `if (!canManageMeeting(user, meeting)) throw new Error("Only Admins and Secretariat can delete management meetings")`
7. Get documents for storage cleanup:
   ```typescript
   const existingDocuments = normaliseMeetingDocuments(meeting.documents);
   ```
8. Delete meeting (cascade deletes MeetingAttendee records):
   ```typescript
   await prisma.meeting.delete({
     where: { id: parsed.data.meetingId }
   });
   ```
9. Clean up storage for each document (non-blocking, log errors):
   ```typescript
   import { deleteStoredObject } from "@/lib/storage/client";

   for (const doc of existingDocuments) {
     try {
       await deleteStoredObject(doc.storageKey);
     } catch (error) {
       console.error("Failed to delete document from storage", { storageKey: doc.storageKey, error });
     }
   }
   ```
10. Log activity: `logActivity({ skillId: null, userId: user.id, action: "ManagementMeetingDeleted", payload: { meetingId: meeting.id, title: meeting.title } })`
11. Revalidate paths: `revalidatePath("/meetings")` and `revalidatePath("/hub/meetings")`
12. Return `{ success: true }`

**Error handling pattern:**
- Meeting not found -> Error
- Not a management meeting -> Error (prevents using this action on skill meetings)
- No permission -> Error
- Storage cleanup failure -> Log and continue (don't fail the delete)
  </action>
  <verify>
Run: `npx tsc --noEmit`
Check: File exports deleteManagementMeetingAction
  </verify>
  <done>
Delete action implemented with proper permission checks, cascade delete of attendees, and storage cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add document management actions</name>
  <files>src/app/(dashboard)/management-meeting-actions.ts</files>
  <action>
Add document actions to the file. Follow the exact pattern from skill meeting-actions.ts but adapted for management meetings.

**addManagementMeetingDocumentAction(meetingId: string, fileData: {...}, undefined)**

Note: Third parameter is undefined (no skillId for management meetings) but we keep signature similar for consistency.

Schema:
```typescript
const addManagementMeetingDocumentSchema = z.object({
  meetingId: z.string().min(1),
  storageKey: z.string().min(1),
  fileName: z.string().min(1),
  fileSize: z.number().int().positive(),
  mimeType: z.string().min(1)
});
```

Logic:
1. `const user = await requireUser()`
2. Validate with schema
3. Fetch meeting: `prisma.meeting.findUnique({ where: { id: meetingId } })`
4. Check meeting exists: `if (!meeting) throw new Error("Meeting not found")`
5. Check is management meeting: `if (meeting.skillId !== null) throw new Error("This action is only for management meetings")`
6. Check permission: `if (!canManageMeeting(user, meeting)) throw new Error("Only Admins and Secretariat can add documents to management meetings")`
7. Parse existing documents: `const existingDocuments = normaliseMeetingDocuments(meeting.documents)`
8. Create new document object:
   ```typescript
   const newDocument: MeetingDocument = {
     id: createId(),
     fileName: parsed.data.fileName,
     storageKey: parsed.data.storageKey,
     fileSize: parsed.data.fileSize,
     mimeType: parsed.data.mimeType,
     uploadedAt: new Date().toISOString()
   };
   ```
9. Update meeting with new document:
   ```typescript
   await prisma.meeting.update({
     where: { id: meetingId },
     data: {
       documents: serialiseMeetingDocuments([...existingDocuments, newDocument])
     }
   });
   ```
10. Log activity: `logActivity({ skillId: null, userId: user.id, action: "ManagementMeetingDocumentAdded", payload: { meetingId, documentId: newDocument.id, fileName: newDocument.fileName } })`
11. Revalidate paths
12. Return `{ success: true, documentId: newDocument.id }`

**deleteManagementMeetingDocumentAction(meetingId: string, docId: string)**

Schema:
```typescript
const deleteManagementMeetingDocumentSchema = z.object({
  meetingId: z.string().min(1),
  docId: z.string().min(1)
});
```

Logic:
1. `const user = await requireUser()`
2. Validate with schema
3. Fetch meeting
4. Check meeting exists and is management meeting (skillId === null)
5. Check permission with canManageMeeting
6. Parse existing documents
7. Find document to delete: `const documentToDelete = existingDocuments.find((doc) => doc.id === docId)`
8. If not found: `throw new Error("Document not found")`
9. Filter out document: `const updatedDocuments = existingDocuments.filter((doc) => doc.id !== docId)`
10. Update meeting with filtered documents
11. Delete from storage (non-blocking):
    ```typescript
    try {
      await deleteStoredObject(documentToDelete.storageKey);
    } catch (error) {
      console.error("Failed to delete document from storage", error);
    }
    ```
12. Log activity: `logActivity({ skillId: null, userId: user.id, action: "ManagementMeetingDocumentDeleted", payload: { meetingId, documentId: docId, fileName: documentToDelete.fileName } })`
13. Revalidate paths
14. Return `{ success: true }`
  </action>
  <verify>
Run: `npx tsc --noEmit`
Check: File exports addManagementMeetingDocumentAction and deleteManagementMeetingDocumentAction
  </verify>
  <done>
Document add/delete actions implemented with proper validation, permission checks, storage management, and activity logging.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add link management actions</name>
  <files>src/app/(dashboard)/management-meeting-actions.ts</files>
  <action>
Add link actions to the file. Follow the exact pattern from skill meeting-actions.ts.

**addManagementMeetingLinkAction(meetingId: string, linkData: { label: string; url: string })**

Schema:
```typescript
const addManagementMeetingLinkSchema = z.object({
  meetingId: z.string().min(1),
  label: z.string().min(1, "Label is required"),
  url: z.string().url("Invalid URL")
});
```

Logic:
1. `const user = await requireUser()`
2. Validate with schema (combine meetingId and linkData)
3. Fetch meeting
4. Check meeting exists and is management meeting (skillId === null)
5. Check permission with canManageMeeting
6. Parse existing links: `const existingLinks = normaliseMeetingLinks(meeting.links)`
7. Create new link:
   ```typescript
   const newLink: MeetingLink = {
     id: createId(),
     label: parsed.data.label,
     url: parsed.data.url,
     addedAt: new Date().toISOString()
   };
   ```
8. Update meeting:
   ```typescript
   await prisma.meeting.update({
     where: { id: meetingId },
     data: {
       links: serialiseMeetingLinks([...existingLinks, newLink])
     }
   });
   ```
9. Log activity: `logActivity({ skillId: null, userId: user.id, action: "ManagementMeetingLinkAdded", payload: { meetingId, linkId: newLink.id, label: newLink.label, url: newLink.url } })`
10. Revalidate paths
11. Return `{ success: true, linkId: newLink.id }`

**removeManagementMeetingLinkAction(meetingId: string, linkId: string)**

Schema:
```typescript
const removeManagementMeetingLinkSchema = z.object({
  meetingId: z.string().min(1),
  linkId: z.string().min(1)
});
```

Logic:
1. `const user = await requireUser()`
2. Validate with schema
3. Fetch meeting
4. Check meeting exists and is management meeting (skillId === null)
5. Check permission with canManageMeeting
6. Parse existing links
7. Find link to remove: `const linkToDelete = existingLinks.find((link) => link.id === linkId)`
8. If not found: `throw new Error("Link not found")`
9. Filter out link: `const updatedLinks = existingLinks.filter((link) => link.id !== linkId)`
10. Update meeting with filtered links
11. Log activity: `logActivity({ skillId: null, userId: user.id, action: "ManagementMeetingLinkRemoved", payload: { meetingId, linkId, label: linkToDelete.label } })`
12. Revalidate paths
13. Return `{ success: true }`
  </action>
  <verify>
Run: `npx tsc --noEmit`
Check: File exports addManagementMeetingLinkAction and removeManagementMeetingLinkAction
  </verify>
  <done>
Link add/remove actions implemented with proper validation, permission checks, and activity logging.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create meeting visibility queries and Secretariat helper</name>
  <files>src/lib/meeting-queries.ts</files>
  <action>
Create new file `src/lib/meeting-queries.ts` with role-based meeting retrieval and Secretariat member lookup.

```typescript
import { Role } from "@prisma/client";
import { prisma } from "@/lib/prisma";

interface UserContext {
  id: string;
  role: Role;
  isAdmin: boolean;
}

/**
 * Get available Secretariat members for meeting attendee selection.
 * Returns all users with Role.Secretariat, ordered by name.
 * Used by UI when creating management meetings.
 */
export async function getSecretariatMembers() {
  return prisma.user.findMany({
    where: { role: Role.Secretariat },
    select: {
      id: true,
      name: true,
      email: true
    },
    orderBy: { name: "asc" }
  });
}

/**
 * Check if a meeting is a management meeting (not tied to a skill).
 */
export function isManagementMeeting(meeting: { skillId: string | null }): boolean {
  return meeting.skillId === null;
}

/**
 * Get meetings visible to a user based on their role.
 *
 * - Admin: all meetings
 * - SA: all management meetings + meetings for skills they advise
 * - SCM: meetings for skills they manage (no management meetings)
 * - Secretariat: only management meetings they're invited to
 * - SkillTeam: meetings for skills they're members of
 * - Pending/other: no meetings
 */
export async function getMeetingsForUser(user: UserContext) {
  // Admin sees everything
  if (user.isAdmin) {
    return prisma.meeting.findMany({
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // Skill Advisor: all management meetings + their skill meetings
  if (user.role === Role.SA) {
    const userSkills = await prisma.skill.findMany({
      where: { saId: user.id },
      select: { id: true }
    });
    const skillIds = userSkills.map(s => s.id);

    return prisma.meeting.findMany({
      where: {
        OR: [
          { skillId: null }, // All management meetings
          { skillId: { in: skillIds } } // Their skill meetings
        ]
      },
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // SCM: their skill meetings only (no management meetings)
  if (user.role === Role.SCM) {
    const userSkills = await prisma.skill.findMany({
      where: { scmId: user.id },
      select: { id: true }
    });
    const skillIds = userSkills.map(s => s.id);

    return prisma.meeting.findMany({
      where: { skillId: { in: skillIds } },
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // Secretariat: only management meetings they're invited to
  if (user.role === Role.Secretariat) {
    return prisma.meeting.findMany({
      where: {
        skillId: null,
        attendees: {
          some: { userId: user.id }
        }
      },
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // SkillTeam: their skill meetings only
  if (user.role === Role.SkillTeam) {
    const memberships = await prisma.skillMember.findMany({
      where: { userId: user.id },
      select: { skillId: true }
    });
    const skillIds = memberships.map(m => m.skillId);

    return prisma.meeting.findMany({
      where: { skillId: { in: skillIds } },
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // Pending users see nothing
  return [];
}
```

**Key points:**
- `getSecretariatMembers()` returns { id, name, email } for UI dropdown population (supports MEET-03 attendee selection)
- `isManagementMeeting()` is a simple type guard for UI logic
- `getMeetingsForUser()` handles all role-based visibility rules
  </action>
  <verify>
Run: `npx tsc --noEmit`
Check: No TypeScript errors
Check: File exports getMeetingsForUser, getSecretariatMembers, and isManagementMeeting
  </verify>
  <done>
Meeting visibility queries created with role-based rules. Secretariat helper added for attendee selection UI.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` - TypeScript compilation passes
2. Files exist with correct exports:
   - `src/app/(dashboard)/management-meeting-actions.ts` exports all 7 actions
   - `src/lib/meeting-queries.ts` exports getMeetingsForUser, getSecretariatMembers, isManagementMeeting
3. All 7 server actions have:
   - Zod schema validation
   - Permission checks using helpers from 02-01
   - Activity logging with skillId: null
   - Path revalidation
</verification>

<success_criteria>
- [ ] Management meeting create action with email sending
- [ ] Management meeting update minutes action
- [ ] Management meeting delete action with storage cleanup
- [ ] Document add action with proper validation
- [ ] Document delete action with storage cleanup
- [ ] Link add action with URL validation
- [ ] Link remove action
- [ ] getSecretariatMembers() for attendee selection UI
- [ ] getMeetingsForUser() with role-based visibility
- [ ] isManagementMeeting() type guard
- [ ] Permission checks enforced on all mutations
- [ ] Activity logging works with null skillId
- [ ] All TypeScript compilation passes
- [ ] Requirements covered: AUTH-01 to AUTH-06, MEET-01 to MEET-08, EMAIL-01 to EMAIL-03, SAFE-03
</success_criteria>

<output>
After completion, create `.planning/phases/02-permission-&-business-logic-layer/02-02-SUMMARY.md`
</output>
