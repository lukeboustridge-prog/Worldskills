---
phase: 02-permission-business-logic
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/(dashboard)/management-meeting-actions.ts
  - src/lib/meeting-queries.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create a management meeting via server action"
    - "Secretariat can create a management meeting via server action"
    - "Management meeting creation sends emails to all SAs and selected Secretariat"
    - "SA can retrieve all management meetings plus their skill meetings"
    - "Secretariat member can retrieve only management meetings they're invited to"
    - "Management meeting can be updated (minutes, action points, documents, links)"
    - "Management meeting can be deleted by Admin or Secretariat"
  artifacts:
    - path: "src/app/(dashboard)/management-meeting-actions.ts"
      provides: "Server actions for management meeting CRUD"
      exports: ["createManagementMeetingAction", "updateManagementMeetingAction", "deleteManagementMeetingAction", "addManagementMeetingDocumentAction", "deleteManagementMeetingDocumentAction", "addManagementMeetingLinkAction", "removeManagementMeetingLinkAction"]
    - path: "src/lib/meeting-queries.ts"
      provides: "Meeting retrieval functions by role"
      exports: ["getMeetingsForUser"]
  key_links:
    - from: "src/app/(dashboard)/management-meeting-actions.ts"
      to: "src/lib/permissions/meeting.ts"
      via: "Permission checks before mutations"
      pattern: "canCreateManagementMeeting|canManageMeeting"
    - from: "src/app/(dashboard)/management-meeting-actions.ts"
      to: "src/lib/email/meeting-invitation.ts"
      via: "Send invitations after creation"
      pattern: "sendMeetingInvitation"
    - from: "src/app/(dashboard)/management-meeting-actions.ts"
      to: "src/lib/activity.ts"
      via: "Log management meeting activities"
      pattern: "logActivity.*skillId.*null"
    - from: "src/lib/meeting-queries.ts"
      to: "prisma.meeting.findMany"
      via: "Database queries with role-based filtering"
      pattern: "prisma\\.meeting\\.findMany"
---

<objective>
Create server actions for management meeting CRUD operations and meeting visibility queries that respect role-based access control.

Purpose: Implements AUTH-01 to AUTH-06 (authorization), MEET-01 to MEET-08 (meeting management), EMAIL-01 to EMAIL-03 (calendar invites). This plan wires together the permission helpers, email templates, and activity logging from Plan 02-01.

Output: Server actions that enforce authorization rules and a unified meeting query function that returns appropriate meetings based on user role.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-permission-&-business-logic-layer/02-RESEARCH.md
@.planning/phases/02-permission-&-business-logic-layer/02-01-SUMMARY.md

# Existing patterns to follow
@src/app/(dashboard)/skills/[skillId]/meeting-actions.ts
@src/lib/auth.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create management meeting server actions</name>
  <files>src/app/(dashboard)/management-meeting-actions.ts</files>
  <action>
Create new file `src/app/(dashboard)/management-meeting-actions.ts` with "use server" directive.

Follow the pattern from existing `meeting-actions.ts` but adapted for management meetings:

**1. createManagementMeetingAction(formData: FormData)**
Schema (Zod):
- title: z.string().min(2)
- startTime: z.string().refine(valid date)
- endTime: z.string().refine(valid date)
- meetingLink: z.string().url().optional().or(z.literal(""))
- secretariatAttendeeIds: z.string() (JSON array of user IDs)
- initialDocuments: z.string().optional() (JSON)
- initialLinks: z.string().optional() (JSON)

Logic:
1. `const user = await requireUser()`
2. `if (!canCreateManagementMeeting(user)) throw new Error("Only Admins and Secretariat can create management meetings")`
3. Validate with Zod .safeParse()
4. Validate endTime > startTime
5. Parse secretariatAttendeeIds from JSON
6. Fetch all SAs: `prisma.user.findMany({ where: { role: Role.SA } })`
7. Fetch selected Secretariat members from secretariatAttendeeIds
8. Create meeting with skillId: null
9. Create MeetingAttendee records for selected Secretariat members ONLY (SAs don't need attendee records - they see all management meetings by default)
10. Send email invitation to all SAs + selected Secretariat (combine email arrays, use meetingType: "management", skillName: null)
11. logActivity({ skillId: null, userId, action: "ManagementMeetingCreated", payload: { meetingId, title, attendeeCount } })
12. revalidatePath("/meetings") and revalidatePath("/hub/meetings")
13. Return { success: true, meetingId }

**2. updateManagementMeetingMinutesAction(formData: FormData)**
Schema: meetingId, minutes?, actionPoints?
Logic:
1. requireUser()
2. Fetch meeting with skillId check (must be null)
3. canManageMeeting(user, meeting) - must be Admin/Secretariat
4. Update minutes and actionPoints
5. logActivity with skillId: null
6. revalidatePath

**3. deleteManagementMeetingAction(formData: FormData)**
Schema: meetingId
Logic:
1. requireUser()
2. Fetch meeting (must have skillId: null)
3. canManageMeeting check
4. Delete meeting (cascade deletes attendees)
5. logActivity with skillId: null
6. revalidatePath

**4. Document actions** (addManagementMeetingDocumentAction, deleteManagementMeetingDocumentAction)
Similar to skill meeting document actions but:
- No skillId in schema
- Check skillId is null on meeting
- Use canManageMeeting for authorization
- logActivity with skillId: null

**5. Link actions** (addManagementMeetingLinkAction, removeManagementMeetingLinkAction)
Similar pattern.

Import helpers:
- from "@/lib/permissions/meeting": canCreateManagementMeeting, canManageMeeting
- from "@/lib/email/meeting-invitation": sendMeetingInvitation
- from "@/lib/activity": logActivity
- from "@/lib/auth": requireUser
- from "@/lib/prisma": prisma
- Role from "@prisma/client"
- Zod for validation
- revalidatePath from "next/cache"

Reuse helper functions from meeting-actions.ts (normaliseMeetingDocuments, normaliseMeetingLinks, serialise*, createId) by importing them or copying locally.
  </action>
  <verify>
Run: `npx tsc --noEmit`
Check: No TypeScript errors
Check: File exports all required actions
  </verify>
  <done>
Management meeting server actions created with proper authorization, email sending, and activity logging. All mutations enforce Admin/Secretariat permissions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create meeting visibility query functions</name>
  <files>src/lib/meeting-queries.ts</files>
  <action>
Create new file `src/lib/meeting-queries.ts` with role-based meeting retrieval:

**getMeetingsForUser(user: { id: string; role: Role; isAdmin: boolean })**

This unified function returns appropriate meetings based on user role:

```typescript
import { Role } from "@prisma/client";
import { prisma } from "@/lib/prisma";

interface UserContext {
  id: string;
  role: Role;
  isAdmin: boolean;
}

export async function getMeetingsForUser(user: UserContext) {
  // Admin sees everything
  if (user.isAdmin) {
    return prisma.meeting.findMany({
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // Skill Advisor: all management meetings + their skill meetings
  if (user.role === Role.SA) {
    // Get skills where user is SA
    const userSkills = await prisma.skill.findMany({
      where: { saId: user.id },
      select: { id: true }
    });
    const skillIds = userSkills.map(s => s.id);

    return prisma.meeting.findMany({
      where: {
        OR: [
          { skillId: null }, // All management meetings
          { skillId: { in: skillIds } } // Their skill meetings
        ]
      },
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // SCM: their skill meetings only (no management meetings)
  if (user.role === Role.SCM) {
    const userSkills = await prisma.skill.findMany({
      where: { scmId: user.id },
      select: { id: true }
    });
    const skillIds = userSkills.map(s => s.id);

    return prisma.meeting.findMany({
      where: { skillId: { in: skillIds } },
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // Secretariat: only management meetings they're invited to
  if (user.role === Role.Secretariat) {
    return prisma.meeting.findMany({
      where: {
        skillId: null,
        attendees: {
          some: { userId: user.id }
        }
      },
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // SkillTeam: their skill meetings only
  if (user.role === Role.SkillTeam) {
    const memberships = await prisma.skillMember.findMany({
      where: { userId: user.id },
      select: { skillId: true }
    });
    const skillIds = memberships.map(m => m.skillId);

    return prisma.meeting.findMany({
      where: { skillId: { in: skillIds } },
      include: {
        skill: { select: { id: true, name: true } },
        attendees: {
          include: { user: { select: { id: true, name: true, email: true } } }
        }
      },
      orderBy: { startTime: "desc" }
    });
  }

  // Pending users see nothing
  return [];
}
```

Also export helper to check if meeting is management meeting:
```typescript
export function isManagementMeeting(meeting: { skillId: string | null }): boolean {
  return meeting.skillId === null;
}
```

This function will be used by the hub meetings page (Phase 3) to show appropriate meetings.
  </action>
  <verify>
Run: `npx tsc --noEmit`
Check: No TypeScript errors
Check: File exports getMeetingsForUser and isManagementMeeting
  </verify>
  <done>
Meeting visibility queries created. SAs see all management + their skill meetings. Secretariat sees only invited management meetings. SCM/SkillTeam see only their skill meetings.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` - TypeScript compilation passes
2. Files exist with correct exports:
   - `src/app/(dashboard)/management-meeting-actions.ts` exports create/update/delete actions
   - `src/lib/meeting-queries.ts` exports getMeetingsForUser
3. Manual test (optional): Create a test meeting via database seed or dev tool to verify queries work
</verification>

<success_criteria>
- [ ] Management meeting CRUD server actions created
- [ ] Permission checks enforced on all mutations
- [ ] Email invitations sent on meeting creation
- [ ] Activity logging works with null skillId
- [ ] Meeting visibility queries respect role-based rules
- [ ] All TypeScript compilation passes
- [ ] Requirements covered: AUTH-01 to AUTH-06, MEET-01 to MEET-08, EMAIL-01 to EMAIL-03, SAFE-03
</success_criteria>

<output>
After completion, create `.planning/phases/02-permission-&-business-logic-layer/02-02-SUMMARY.md`
</output>
