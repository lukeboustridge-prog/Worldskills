---
phase: 02-admin-curation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/descriptors.ts
  - src/lib/duplicate-detection.ts
  - src/app/(dashboard)/settings/descriptors/actions.ts
autonomous: true

must_haves:
  truths:
    - "Server Action creates descriptor with all fields and validates with Zod"
    - "Server Action updates descriptor and validates with Zod"
    - "Server Action soft-deletes descriptor (sets deletedAt, deletedBy)"
    - "Duplicate detection returns similar descriptors using pg_trgm similarity"
    - "Query functions filter out soft-deleted descriptors by default"
  artifacts:
    - path: "src/lib/descriptors.ts"
      provides: "Query functions for descriptors (getAll, getById, search)"
      exports: ["getAllDescriptors", "getDescriptorById"]
    - path: "src/lib/duplicate-detection.ts"
      provides: "Similarity search using pg_trgm"
      exports: ["findSimilarDescriptors"]
    - path: "src/app/(dashboard)/settings/descriptors/actions.ts"
      provides: "Server Actions for CRUD operations"
      exports: ["createDescriptorAction", "updateDescriptorAction", "deleteDescriptorAction"]
  key_links:
    - from: "src/app/(dashboard)/settings/descriptors/actions.ts"
      to: "prisma.descriptor"
      via: "Prisma client operations"
      pattern: "prisma\\.descriptor\\.(create|update|findMany)"
    - from: "src/lib/duplicate-detection.ts"
      to: "PostgreSQL pg_trgm"
      via: "Raw SQL query with similarity function"
      pattern: "similarity.*criterionName"
---

<objective>
Implement Server Actions for descriptor CRUD operations with Zod validation, duplicate detection using pg_trgm similarity, and query functions for listing/filtering descriptors.

Purpose: Provide the data layer for the admin curation UI - all create, read, update, delete operations with validation, duplicate warnings, and soft delete support.

Output: Three TypeScript modules providing complete descriptor management backend.
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-admin-curation/02-RESEARCH.md
@.planning/phases/02-admin-curation/02-01-SUMMARY.md

Reference existing Server Action pattern:
@src/app/(dashboard)/settings/resources/actions.ts

Key patterns from existing code:
- Use `requireAdminUser()` from `@/lib/auth` for authorization
- Use Zod schemas with `safeParse()` for validation
- Redirect with query params for error/success messages
- Use `revalidatePath()` to refresh cached data
- Use `prisma` from `@/lib/prisma`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query functions for descriptors</name>
  <files>src/lib/descriptors.ts</files>
  <action>
Create `src/lib/descriptors.ts` with the following functions:

```typescript
import { prisma } from "@/lib/prisma";
import { QualityIndicator } from "@prisma/client";

export interface DescriptorFilters {
  skillName?: string;
  sector?: string;
  category?: string;
  qualityIndicator?: QualityIndicator;
  tag?: string;
  search?: string;
  includeDeleted?: boolean;
}

/**
 * Get all descriptors with optional filtering.
 * By default excludes soft-deleted descriptors.
 */
export async function getAllDescriptors(filters: DescriptorFilters = {}) {
  const where: any = {};

  // Always filter out deleted unless explicitly requested
  if (!filters.includeDeleted) {
    where.deletedAt = null;
  }

  if (filters.skillName) {
    where.skillName = filters.skillName;
  }

  if (filters.sector) {
    where.sector = filters.sector;
  }

  if (filters.category) {
    where.category = filters.category;
  }

  if (filters.qualityIndicator) {
    where.qualityIndicator = filters.qualityIndicator;
  }

  if (filters.tag) {
    where.tags = { has: filters.tag };
  }

  if (filters.search) {
    where.OR = [
      { criterionName: { contains: filters.search, mode: "insensitive" } },
      { code: { contains: filters.search, mode: "insensitive" } },
      { excellent: { contains: filters.search, mode: "insensitive" } },
      { good: { contains: filters.search, mode: "insensitive" } },
      { pass: { contains: filters.search, mode: "insensitive" } },
      { belowPass: { contains: filters.search, mode: "insensitive" } },
    ];
  }

  return prisma.descriptor.findMany({
    where,
    orderBy: [
      { skillName: "asc" },
      { code: "asc" },
    ],
  });
}

/**
 * Get a single descriptor by ID.
 * Returns null if not found or soft-deleted (unless includeDeleted=true).
 */
export async function getDescriptorById(id: string, includeDeleted = false) {
  const descriptor = await prisma.descriptor.findUnique({
    where: { id },
  });

  if (!descriptor) return null;
  if (!includeDeleted && descriptor.deletedAt) return null;

  return descriptor;
}

/**
 * Get distinct values for filter dropdowns.
 */
export async function getDescriptorFilterOptions() {
  const [skills, sectors, categories, tags] = await Promise.all([
    prisma.descriptor.findMany({
      where: { deletedAt: null },
      select: { skillName: true },
      distinct: ["skillName"],
      orderBy: { skillName: "asc" },
    }),
    prisma.descriptor.findMany({
      where: { deletedAt: null, sector: { not: null } },
      select: { sector: true },
      distinct: ["sector"],
      orderBy: { sector: "asc" },
    }),
    prisma.descriptor.findMany({
      where: { deletedAt: null, category: { not: null } },
      select: { category: true },
      distinct: ["category"],
      orderBy: { category: "asc" },
    }),
    // Get unique tags (requires raw query since tags is array)
    prisma.$queryRaw<{ tag: string }[]>`
      SELECT DISTINCT unnest(tags) as tag
      FROM "Descriptor"
      WHERE "deletedAt" IS NULL
      ORDER BY tag
    `,
  ]);

  return {
    skills: skills.map((s) => s.skillName),
    sectors: sectors.map((s) => s.sector!),
    categories: categories.map((c) => c.category!),
    tags: tags.map((t) => t.tag),
  };
}
```

Follow existing module patterns in `src/lib/` (e.g., `src/lib/resources.ts` if it exists).
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles without errors</verify>
  <done>Query functions created with filtering, soft-delete exclusion, and filter options</done>
</task>

<task type="auto">
  <name>Task 2: Create duplicate detection module</name>
  <files>src/lib/duplicate-detection.ts</files>
  <action>
Create `src/lib/duplicate-detection.ts` with pg_trgm similarity search:

```typescript
import { prisma } from "@/lib/prisma";

export interface SimilarDescriptor {
  id: string;
  code: string;
  criterionName: string;
  skillName: string;
  similarity: number;
}

/**
 * Find descriptors with similar criterion names using pg_trgm trigram similarity.
 * Returns descriptors with similarity > threshold, ordered by similarity DESC.
 *
 * @param criterionName - The criterion name to compare against
 * @param threshold - Minimum similarity score (0-1), default 0.4
 * @param excludeId - Optional ID to exclude (for edit mode)
 * @param limit - Maximum results to return, default 5
 */
export async function findSimilarDescriptors(
  criterionName: string,
  threshold = 0.4,
  excludeId?: string,
  limit = 5
): Promise<SimilarDescriptor[]> {
  if (!criterionName || criterionName.length < 3) {
    return [];
  }

  const excludeClause = excludeId ? `AND id != '${excludeId}'` : "";

  const similar = await prisma.$queryRaw<SimilarDescriptor[]>`
    SELECT
      id,
      code,
      "criterionName",
      "skillName",
      similarity("criterionName", ${criterionName}) as similarity
    FROM "Descriptor"
    WHERE
      similarity("criterionName", ${criterionName}) > ${threshold}
      AND "deletedAt" IS NULL
      ${excludeId ? Prisma.sql`AND id != ${excludeId}` : Prisma.empty}
    ORDER BY similarity DESC
    LIMIT ${limit}
  `;

  return similar;
}

/**
 * Check if a descriptor with the same code exists within a skill.
 * Used to warn about potential duplicates before create/update.
 */
export async function checkCodeExists(
  skillName: string,
  code: string,
  excludeId?: string
): Promise<boolean> {
  const existing = await prisma.descriptor.findFirst({
    where: {
      skillName,
      code,
      deletedAt: null,
      ...(excludeId ? { id: { not: excludeId } } : {}),
    },
    select: { id: true },
  });

  return !!existing;
}
```

Note: The raw SQL query uses pg_trgm `similarity()` function which requires the extension to be enabled (done in Plan 02-01).

Import `Prisma` from `@prisma/client` for `Prisma.sql` and `Prisma.empty` template literals.
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles without errors</verify>
  <done>Duplicate detection module with pg_trgm similarity search and code uniqueness check</done>
</task>

<task type="auto">
  <name>Task 3: Create Server Actions for descriptor CRUD</name>
  <files>src/app/(dashboard)/settings/descriptors/actions.ts</files>
  <action>
Create `src/app/(dashboard)/settings/descriptors/actions.ts` following the existing pattern from `src/app/(dashboard)/settings/resources/actions.ts`:

```typescript
"use server";

import { QualityIndicator } from "@prisma/client";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { z } from "zod";

import { requireAdminUser, getServerSession } from "@/lib/auth";
import { prisma } from "@/lib/prisma";

// Zod schema for descriptor validation
const descriptorSchema = z.object({
  code: z.string().min(1, "Code is required"),
  criterionName: z.string().min(3, "Criterion name must be at least 3 characters"),
  excellent: z.string().optional(),
  good: z.string().optional(),
  pass: z.string().optional(),
  belowPass: z.string().optional(),
  skillName: z.string().min(1, "Source skill is required"),
  sector: z.string().optional(),
  category: z.string().optional(),
  tags: z.string().optional(), // Comma-separated, parsed below
  qualityIndicator: z.nativeEnum(QualityIndicator).optional(),
}).refine(
  (data) => data.criterionName.length >= 5 || data.excellent || data.good || data.pass || data.belowPass,
  { message: "Criterion name must be 5+ characters, or at least one performance level is required" }
);

const updateDescriptorSchema = descriptorSchema.extend({
  id: z.string().min(1, "Descriptor ID is required"),
});

const deleteDescriptorSchema = z.object({
  id: z.string().min(1, "Descriptor ID is required"),
});

/**
 * Parse comma-separated tags string into array
 */
function parseTags(tagsInput: string | undefined): string[] {
  if (!tagsInput) return [];
  return tagsInput
    .split(",")
    .map((tag) => tag.trim())
    .filter((tag) => tag.length > 0);
}

/**
 * Create a new descriptor
 */
export async function createDescriptorAction(formData: FormData) {
  await requireAdminUser();

  const parsedResult = descriptorSchema.safeParse({
    code: formData.get("code"),
    criterionName: formData.get("criterionName"),
    excellent: formData.get("excellent") || undefined,
    good: formData.get("good") || undefined,
    pass: formData.get("pass") || undefined,
    belowPass: formData.get("belowPass") || undefined,
    skillName: formData.get("skillName"),
    sector: formData.get("sector") || undefined,
    category: formData.get("category") || undefined,
    tags: formData.get("tags") || undefined,
    qualityIndicator: formData.get("qualityIndicator") || undefined,
  });

  if (!parsedResult.success) {
    const firstError = parsedResult.error.errors[0]?.message ?? "Please review the form";
    const params = new URLSearchParams({ error: firstError });
    return redirect(`/settings/descriptors/create?${params.toString()}`);
  }

  const data = parsedResult.data;
  const tags = parseTags(data.tags);

  try {
    await prisma.descriptor.create({
      data: {
        code: data.code.trim(),
        criterionName: data.criterionName.trim(),
        excellent: data.excellent?.trim() || null,
        good: data.good?.trim() || null,
        pass: data.pass?.trim() || null,
        belowPass: data.belowPass?.trim() || null,
        skillName: data.skillName.trim(),
        sector: data.sector?.trim() || null,
        category: data.category?.trim() || null,
        tags,
        qualityIndicator: data.qualityIndicator ?? QualityIndicator.REFERENCE,
        source: "Manual",
        version: 1,
      },
    });
  } catch (error) {
    console.error("Failed to create descriptor", error);
    // Check for unique constraint violation
    if ((error as any)?.code === "P2002") {
      const params = new URLSearchParams({ error: "A descriptor with this code already exists for this skill" });
      return redirect(`/settings/descriptors/create?${params.toString()}`);
    }
    const params = new URLSearchParams({ error: "Unable to create descriptor" });
    return redirect(`/settings/descriptors/create?${params.toString()}`);
  }

  revalidatePath("/settings/descriptors");
  const params = new URLSearchParams({ created: "1" });
  return redirect(`/settings/descriptors?${params.toString()}`);
}

/**
 * Update an existing descriptor
 */
export async function updateDescriptorAction(formData: FormData) {
  await requireAdminUser();

  const parsedResult = updateDescriptorSchema.safeParse({
    id: formData.get("id"),
    code: formData.get("code"),
    criterionName: formData.get("criterionName"),
    excellent: formData.get("excellent") || undefined,
    good: formData.get("good") || undefined,
    pass: formData.get("pass") || undefined,
    belowPass: formData.get("belowPass") || undefined,
    skillName: formData.get("skillName"),
    sector: formData.get("sector") || undefined,
    category: formData.get("category") || undefined,
    tags: formData.get("tags") || undefined,
    qualityIndicator: formData.get("qualityIndicator") || undefined,
  });

  if (!parsedResult.success) {
    const firstError = parsedResult.error.errors[0]?.message ?? "Please review the form";
    const id = formData.get("id") as string;
    const params = new URLSearchParams({ error: firstError });
    return redirect(`/settings/descriptors/${id}/edit?${params.toString()}`);
  }

  const data = parsedResult.data;
  const tags = parseTags(data.tags);

  try {
    await prisma.descriptor.update({
      where: { id: data.id },
      data: {
        code: data.code.trim(),
        criterionName: data.criterionName.trim(),
        excellent: data.excellent?.trim() || null,
        good: data.good?.trim() || null,
        pass: data.pass?.trim() || null,
        belowPass: data.belowPass?.trim() || null,
        skillName: data.skillName.trim(),
        sector: data.sector?.trim() || null,
        category: data.category?.trim() || null,
        tags,
        qualityIndicator: data.qualityIndicator,
      },
    });
  } catch (error) {
    console.error("Failed to update descriptor", error);
    if ((error as any)?.code === "P2002") {
      const params = new URLSearchParams({ error: "A descriptor with this code already exists for this skill" });
      return redirect(`/settings/descriptors/${data.id}/edit?${params.toString()}`);
    }
    const params = new URLSearchParams({ error: "Unable to update descriptor" });
    return redirect(`/settings/descriptors/${data.id}/edit?${params.toString()}`);
  }

  revalidatePath("/settings/descriptors");
  revalidatePath(`/settings/descriptors/${data.id}`);
  const params = new URLSearchParams({ updated: "1" });
  return redirect(`/settings/descriptors?${params.toString()}`);
}

/**
 * Soft-delete a descriptor (sets deletedAt, deletedBy)
 */
export async function deleteDescriptorAction(formData: FormData) {
  const session = await requireAdminUser();

  const parsedResult = deleteDescriptorSchema.safeParse({
    id: formData.get("id"),
  });

  if (!parsedResult.success) {
    const params = new URLSearchParams({ error: "Unable to delete descriptor" });
    return redirect(`/settings/descriptors?${params.toString()}`);
  }

  const { id } = parsedResult.data;

  try {
    await prisma.descriptor.update({
      where: { id },
      data: {
        deletedAt: new Date(),
        deletedBy: session.user.id,
      },
    });
  } catch (error) {
    console.error("Failed to delete descriptor", error);
    const params = new URLSearchParams({ error: "Unable to delete descriptor" });
    return redirect(`/settings/descriptors?${params.toString()}`);
  }

  revalidatePath("/settings/descriptors");
  const params = new URLSearchParams({ deleted: "1" });
  return redirect(`/settings/descriptors?${params.toString()}`);
}
```

Adjust the `requireAdminUser()` and `getServerSession()` imports based on actual signatures in `src/lib/auth.ts`. The session should provide `user.id` for the deletedBy field.

Create the parent directories if they don't exist.
  </action>
  <verify>Run `npx tsc --noEmit` to verify TypeScript compiles without errors</verify>
  <done>Server Actions for create, update, soft-delete with Zod validation and proper error handling</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All TypeScript compiles without errors
2. All three modules export their intended functions
3. Server Actions use proper authorization with `requireAdminUser()`
4. Soft delete sets both `deletedAt` and `deletedBy` fields
5. Query functions exclude soft-deleted records by default
6. Duplicate detection uses pg_trgm similarity function
</verification>

<success_criteria>
- [ ] src/lib/descriptors.ts exports getAllDescriptors, getDescriptorById, getDescriptorFilterOptions
- [ ] src/lib/duplicate-detection.ts exports findSimilarDescriptors, checkCodeExists
- [ ] src/app/(dashboard)/settings/descriptors/actions.ts exports create, update, delete actions
- [ ] All actions validate input with Zod schemas
- [ ] Create action sets source="Manual", version=1
- [ ] Delete action performs soft delete (sets deletedAt, deletedBy)
- [ ] Query functions filter out deleted descriptors by default
- [ ] Duplicate detection uses pg_trgm similarity with threshold
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-admin-curation/02-02-SUMMARY.md`
</output>
