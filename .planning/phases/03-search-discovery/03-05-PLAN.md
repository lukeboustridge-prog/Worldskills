---
phase: 03-search-discovery
plan: 05
type: execute
wave: 3
depends_on: ["03-01", "03-03"]
files_modified:
  - package.json
  - src/app/descriptors/page.tsx
  - src/app/descriptors/layout.tsx
  - src/app/descriptors/components/SearchInput.tsx
  - src/app/descriptors/components/FilterPanel.tsx
  - src/app/descriptors/components/Pagination.tsx
  - src/app/descriptors/components/DescriptorList.tsx
  - src/app/providers.tsx
autonomous: true

must_haves:
  truths:
    - "Users can save frequently used search queries via URL persistence"
    - "Search state survives page refresh and can be shared via URL"
    - "Search input is debounced (300ms) to reduce server load"
    - "Filters and search work together in the URL"
    - "User can click to copy descriptor text to clipboard"
  artifacts:
    - path: "package.json"
      provides: "nuqs and use-debounce dependencies"
      contains: "nuqs"
    - path: "src/app/descriptors/page.tsx"
      provides: "Search page with URL-driven search"
      min_lines: 30
    - path: "src/app/descriptors/components/SearchInput.tsx"
      provides: "Debounced search input synced to URL"
      contains: "useDebouncedCallback"
    - path: "src/app/descriptors/components/DescriptorList.tsx"
      provides: "Descriptor cards with copy-to-clipboard"
      contains: "navigator.clipboard"
  key_links:
    - from: "SearchInput.tsx"
      to: "URL params"
      via: "nuqs useQueryState"
      pattern: "useQueryState.*shallow: false"
    - from: "page.tsx"
      to: "searchDescriptors"
      via: "Server-side data fetching with searchParams"
      pattern: "await searchDescriptors"
    - from: "DescriptorList.tsx"
      to: "clipboard API"
      via: "onClick handler with navigator.clipboard.writeText"
      pattern: "navigator\\.clipboard\\.writeText"
---

<objective>
Implement URL-based search state persistence using nuqs library for shareable, bookmarkable searches

Purpose: Enable users to save frequently used searches (SEARCH-06), share search results via URL, and maintain state across navigation
Output: Library installation, search page with URL params, debounced search input, filter components synced to URL, descriptor list with copy functionality
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-discovery/03-RESEARCH.md

# Prior work from this phase
@.planning/phases/03-search-discovery/03-01-SUMMARY.md
@.planning/phases/03-search-discovery/03-03-SUMMARY.md
@src/lib/search-descriptors.ts
@src/lib/queries/facet-counts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install nuqs and use-debounce libraries</name>
  <files>package.json</files>
  <action>
Install the URL state management and debounce libraries:

```bash
npm install nuqs use-debounce
```

Verify the installation:
- nuqs should be version 2.x (type-safe URL params)
- use-debounce should be version 10.x (official Next.js recommendation)

After installation, create or update the providers file to wrap the app with NuqsAdapter:

Check if `src/app/providers.tsx` exists. If it does, add NuqsAdapter. If not, create it:

```typescript
// src/app/providers.tsx
"use client";

import { NuqsAdapter } from "nuqs/adapters/next/app";

export function Providers({ children }: { children: React.ReactNode }) {
  return <NuqsAdapter>{children}</NuqsAdapter>;
}
```

Then update `src/app/layout.tsx` to wrap the app with Providers (if not already done).

Important: Check existing providers pattern in the codebase first. The app may already have a Providers component that wraps other providers (React Query, etc.). In that case, add NuqsAdapter inside the existing Providers.
  </action>
  <verify>
Check package.json has nuqs and use-debounce.
Check that NuqsAdapter is configured in providers.
  </verify>
  <done>nuqs and use-debounce installed, NuqsAdapter configured in app providers</done>
</task>

<task type="auto">
  <name>Task 2: Create all search page components</name>
  <files>src/app/descriptors/components/SearchInput.tsx, src/app/descriptors/components/FilterPanel.tsx, src/app/descriptors/components/Pagination.tsx, src/app/descriptors/components/DescriptorList.tsx</files>
  <action>
Create all the client components FIRST (before the page that uses them).

**Create `src/app/descriptors/components/SearchInput.tsx`:**

```typescript
"use client";

import { useQueryState } from "nuqs";
import { useDebouncedCallback } from "use-debounce";
import { Input } from "@/components/ui/input";
import { Search, X } from "lucide-react";
import { Button } from "@/components/ui/button";

export function SearchInput() {
  const [query, setQuery] = useQueryState("q", {
    defaultValue: "",
    shallow: false, // Trigger server re-render
    throttleMs: 0, // We handle debounce ourselves
  });

  const handleSearch = useDebouncedCallback((value: string) => {
    setQuery(value || null); // null removes param from URL
  }, 300);

  const handleClear = () => {
    setQuery(null);
    // Also clear the input field
    const input = document.querySelector<HTMLInputElement>('input[type="search"]');
    if (input) input.value = "";
  };

  return (
    <div className="relative">
      <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
      <Input
        type="search"
        placeholder="Search descriptors by keyword..."
        defaultValue={query}
        onChange={(e) => handleSearch(e.target.value)}
        className="pl-10 pr-10"
      />
      {query && (
        <Button
          variant="ghost"
          size="sm"
          className="absolute right-1 top-1/2 -translate-y-1/2 h-7 w-7 p-0"
          onClick={handleClear}
        >
          <X className="h-4 w-4" />
          <span className="sr-only">Clear search</span>
        </Button>
      )}
    </div>
  );
}
```

**Create `src/app/descriptors/components/FilterPanel.tsx`:**

```typescript
"use client";

import { useQueryState } from "nuqs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";

interface Facets {
  skillAreas: Array<{ name: string; count: number }>;
  categories: Array<{ name: string; count: number }>;
  qualities: Array<{ name: string; count: number }>;
}

export function FilterPanel({ facets }: { facets: Facets }) {
  const [skill, setSkill] = useQueryState("skill", { shallow: false });
  const [category, setCategory] = useQueryState("category", { shallow: false });
  const [quality, setQuality] = useQueryState("quality", { shallow: false });

  const hasFilters = skill || category || quality;

  const clearAll = () => {
    setSkill(null);
    setCategory(null);
    setQuality(null);
  };

  return (
    <div className="space-y-6">
      {hasFilters && (
        <Button variant="outline" size="sm" onClick={clearAll} className="w-full">
          Clear all filters
        </Button>
      )}

      <FilterSection
        title="Skill Area"
        items={facets.skillAreas.slice(0, 10)}
        activeValue={skill}
        onSelect={(value) => setSkill(value === skill ? null : value)}
      />

      <FilterSection
        title="Category"
        items={facets.categories.slice(0, 10)}
        activeValue={category}
        onSelect={(value) => setCategory(value === category ? null : value)}
      />

      <FilterSection
        title="Quality"
        items={facets.qualities}
        activeValue={quality}
        onSelect={(value) => setQuality(value === quality ? null : value)}
      />
    </div>
  );
}

function FilterSection({
  title,
  items,
  activeValue,
  onSelect,
}: {
  title: string;
  items: Array<{ name: string; count: number }>;
  activeValue: string | null;
  onSelect: (value: string) => void;
}) {
  if (items.length === 0) return null;

  return (
    <div>
      <h3 className="font-semibold mb-3">{title}</h3>
      <div className="space-y-1">
        {items.map(({ name, count }) => (
          <Button
            key={name}
            variant={activeValue === name ? "default" : "ghost"}
            size="sm"
            className="w-full justify-between text-left h-auto py-2"
            onClick={() => onSelect(name)}
          >
            <span className="truncate">{name}</span>
            <Badge variant="secondary" className="ml-2">
              {count}
            </Badge>
          </Button>
        ))}
      </div>
    </div>
  );
}
```

**Create `src/app/descriptors/components/Pagination.tsx`:**

```typescript
"use client";

import { useQueryState } from "nuqs";
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight } from "lucide-react";

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  hasMore: boolean;
}

export function Pagination({ currentPage, totalPages, hasMore }: PaginationProps) {
  const [, setPage] = useQueryState("page", {
    defaultValue: "1",
    shallow: false,
  });

  if (totalPages <= 1) return null;

  const maxPage = Math.min(totalPages, 20); // Limit deep pagination

  return (
    <div className="flex items-center justify-center gap-2 mt-8">
      <Button
        variant="outline"
        size="sm"
        onClick={() => setPage(String(currentPage - 1))}
        disabled={currentPage <= 1}
      >
        <ChevronLeft className="h-4 w-4" />
        Previous
      </Button>

      <span className="text-sm text-muted-foreground px-4">
        Page {currentPage} of {maxPage}
        {totalPages > 20 && " (limited)"}
      </span>

      <Button
        variant="outline"
        size="sm"
        onClick={() => setPage(String(currentPage + 1))}
        disabled={!hasMore || currentPage >= maxPage}
      >
        Next
        <ChevronRight className="h-4 w-4" />
      </Button>
    </div>
  );
}
```

**Create `src/app/descriptors/components/DescriptorList.tsx` WITH click-to-copy functionality:**

```typescript
"use client";

import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Copy, Check } from "lucide-react";
import type { SearchResult } from "@/lib/search-descriptors";

export function DescriptorList({ results }: { results: SearchResult[] }) {
  if (results.length === 0) {
    return (
      <div className="text-center py-12 text-muted-foreground">
        No descriptors found. Try adjusting your search or filters.
      </div>
    );
  }

  return (
    <div className="space-y-4 mt-4">
      {results.map((descriptor) => (
        <DescriptorCard key={descriptor.id} descriptor={descriptor} />
      ))}
    </div>
  );
}

function DescriptorCard({ descriptor }: { descriptor: SearchResult }) {
  const [copiedField, setCopiedField] = useState<string | null>(null);

  const copyToClipboard = async (text: string, field: string) => {
    try {
      await navigator.clipboard.writeText(text);
      setCopiedField(field);
      setTimeout(() => setCopiedField(null), 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  };

  const CopyButton = ({ text, field }: { text: string; field: string }) => (
    <Button
      variant="ghost"
      size="sm"
      className="h-6 w-6 p-0 opacity-0 group-hover:opacity-100 transition-opacity"
      onClick={() => copyToClipboard(text, field)}
      title="Copy to clipboard"
    >
      {copiedField === field ? (
        <Check className="h-3 w-3 text-green-500" />
      ) : (
        <Copy className="h-3 w-3" />
      )}
    </Button>
  );

  return (
    <Card>
      <CardHeader className="pb-2">
        <div className="flex items-start justify-between">
          <div className="group flex items-start gap-2">
            <div>
              <CardTitle className="text-lg">
                {descriptor.criterionName}
              </CardTitle>
              <div className="text-sm text-muted-foreground mt-1">
                {descriptor.skillName} - {descriptor.code}
              </div>
            </div>
            <CopyButton text={descriptor.criterionName} field="criterion" />
          </div>
          <div className="flex gap-2">
            {descriptor.category && (
              <Badge variant="outline">{descriptor.category}</Badge>
            )}
            <Badge
              variant={
                descriptor.qualityIndicator === "EXCELLENT"
                  ? "default"
                  : "secondary"
              }
            >
              {descriptor.qualityIndicator}
            </Badge>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-2">
        {descriptor.excellent && (
          <div className="group flex items-start gap-2 text-sm">
            <div className="flex-1">
              <span className="font-medium">Excellent:</span>{" "}
              {descriptor.excellent.substring(0, 200)}
              {descriptor.excellent.length > 200 && "..."}
            </div>
            <CopyButton text={descriptor.excellent} field="excellent" />
          </div>
        )}
        {descriptor.good && (
          <div className="group flex items-start gap-2 text-sm">
            <div className="flex-1">
              <span className="font-medium">Good:</span>{" "}
              {descriptor.good.substring(0, 200)}
              {descriptor.good.length > 200 && "..."}
            </div>
            <CopyButton text={descriptor.good} field="good" />
          </div>
        )}
        {descriptor.pass && (
          <div className="group flex items-start gap-2 text-sm">
            <div className="flex-1">
              <span className="font-medium">Pass:</span>{" "}
              {descriptor.pass.substring(0, 200)}
              {descriptor.pass.length > 200 && "..."}
            </div>
            <CopyButton text={descriptor.pass} field="pass" />
          </div>
        )}
        {descriptor.rank !== null && (
          <div className="text-xs text-muted-foreground mt-2">
            Relevance: {(descriptor.rank * 100).toFixed(0)}%
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

Key implementation notes:
- `shallow: false` ensures server re-render when query changes
- 300ms debounce as per Next.js recommendation
- `null` removes the query param entirely (clean URLs)
- `navigator.clipboard.writeText()` for modern clipboard API
- Visual feedback with Check icon on successful copy
- Hover-to-reveal copy buttons using group-hover opacity
  </action>
  <verify>
All component files exist in src/app/descriptors/components/.
TypeScript compiles: `npx tsc --noEmit` passes.
  </verify>
  <done>All client components created: SearchInput, FilterPanel, Pagination, DescriptorList with copy functionality</done>
</task>

<task type="auto">
  <name>Task 3: Create search page with URL-driven state</name>
  <files>src/app/descriptors/page.tsx, src/app/descriptors/layout.tsx</files>
  <action>
Create the public descriptor library search page at `src/app/descriptors/page.tsx`:

```typescript
import { Suspense } from "react";
import { searchDescriptors } from "@/lib/search-descriptors";
import { getFacetCounts } from "@/lib/queries/facet-counts";
import { SearchInput } from "./components/SearchInput";
import { FilterPanel } from "./components/FilterPanel";
import { DescriptorList } from "./components/DescriptorList";
import { Pagination } from "./components/Pagination";
import { QualityIndicator } from "@prisma/client";

interface PageProps {
  searchParams: Promise<{
    q?: string;
    skill?: string;
    category?: string;
    quality?: string;
    page?: string;
  }>;
}

export default async function DescriptorsPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const page = Number(params.page) || 1;
  const limit = 20;

  // Fetch search results and facet counts in parallel
  const [searchResponse, facets] = await Promise.all([
    searchDescriptors({
      query: params.q,
      skillName: params.skill,
      category: params.category,
      qualityIndicator: params.quality as QualityIndicator | undefined,
      page,
      limit,
    }),
    getFacetCounts(params.q),
  ]);

  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-6">Descriptor Library</h1>

      <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
        <aside className="md:col-span-1">
          <FilterPanel facets={facets} />
        </aside>

        <main className="md:col-span-3">
          <SearchInput />

          <div className="mt-4 text-sm text-muted-foreground">
            {searchResponse.total} descriptor{searchResponse.total !== 1 ? "s" : ""} found
          </div>

          <Suspense fallback={<div className="py-8">Loading...</div>}>
            <DescriptorList results={searchResponse.results} />
          </Suspense>

          <Pagination
            currentPage={page}
            totalPages={Math.ceil(searchResponse.total / limit)}
            hasMore={searchResponse.hasMore}
          />
        </main>
      </div>
    </div>
  );
}
```

Create a simple layout at `src/app/descriptors/layout.tsx` if needed for the route group. Check if the (dashboard) layout already handles this route - if so, may need to adjust routing structure.

Note: This creates a PUBLIC search page at /descriptors. The admin CRUD pages remain at /settings/descriptors.
  </action>
  <verify>
Visit http://localhost:3000/descriptors - page should load without errors.
Add ?q=safety to URL - page should show search results.
  </verify>
  <done>Search page created with Server Component data fetching, parallel loading of results and facets</done>
</task>

<task type="auto">
  <name>Task 4: Verify complete URL state flow</name>
  <files>None (verification only)</files>
  <action>
Test the complete URL state management flow:

1. **Search state persistence:**
   - Type in search input - URL should update after 300ms delay
   - Clear the input - ?q param should be removed from URL
   - Refresh page with ?q=safety - input should show "safety"

2. **Filter state persistence:**
   - Click a skill filter - URL updates with ?skill=SkillName
   - Click again to deselect - ?skill param removed
   - Multiple filters combine: ?q=safety&skill=Welding&category=Safety

3. **Pagination:**
   - Navigate with pagination - ?page param updates
   - All filters persist when paging: ?q=safety&skill=Welding&page=2

4. **Clipboard functionality:**
   - Hover over a descriptor card - copy buttons appear
   - Click copy button - text copied to clipboard, checkmark appears briefly

5. **Shareable URLs:**
   - Copy URL with filters: localhost:3000/descriptors?q=safety&skill=Welding
   - Open in new tab - same results appear

Run TypeScript compilation check: `npx tsc --noEmit`
  </action>
  <verify>
All URL state flows work correctly.
TypeScript compiles without errors.
Copy-to-clipboard works in browser.
  </verify>
  <done>Complete URL state flow verified, all features working</done>
</task>

</tasks>

<verification>
1. Search state in URL: ?q=safety persists across refresh
2. Filters in URL: ?skill=Welding&category=Safety combine correctly
3. Pagination in URL: ?page=2 navigates correctly
4. Debounce works: Typing doesn't spam server (check network tab)
5. Shareable: Copy URL, open in new tab, same results appear
6. Copy to clipboard: Hover reveals copy buttons, click copies text
7. TypeScript compiles: `npx tsc --noEmit`
</verification>

<success_criteria>
- nuqs and use-debounce libraries installed
- Search page at /descriptors with URL-driven state
- 300ms debounced search input
- Filters update URL and narrow results
- Pagination works with URL params
- URLs are shareable and bookmarkable
- All components use shadcn/ui patterns
- Click-to-copy functionality on descriptor cards
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-discovery/03-05-SUMMARY.md`
</output>
