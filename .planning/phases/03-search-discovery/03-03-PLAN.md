---
phase: 03-search-discovery
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/search-descriptors.ts
  - src/lib/queries/facet-counts.ts
  - scripts/test-pagination-facets.ts
autonomous: true

must_haves:
  truths:
    - "Filters narrow search results without replacing keyword search"
    - "Facet counts update dynamically based on current search query"
    - "Pagination returns correct page of results with total count"
    - "Combined pagination + facets complete in <100ms"
  artifacts:
    - path: "src/lib/search-descriptors.ts"
      provides: "Enhanced search with pagination and total count"
      exports: ["searchDescriptors", "SearchParams", "SearchResponse"]
    - path: "src/lib/queries/facet-counts.ts"
      provides: "Faceted filter counts for dynamic filter panels"
      exports: ["getFacetCounts", "Facets"]
  key_links:
    - from: "getFacetCounts"
      to: "searchDescriptors"
      via: "Same FTS WHERE clause applied to both"
      pattern: "websearch_to_tsquery.*english"
---

<objective>
Enhance search with pagination, total counts, and faceted filter counts for dynamic filter panels

Purpose: Enable paginated search results with accurate counts and filter panels showing "Safety (23), Welding (15)" style facets
Output: Enhanced searchDescriptors with pagination metadata, getFacetCounts for filter panel counts
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-discovery/03-RESEARCH.md

# Prior work from this phase
@.planning/phases/03-search-discovery/03-01-SUMMARY.md
@src/lib/search-descriptors.ts (from 03-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance searchDescriptors with pagination metadata</name>
  <files>src/lib/search-descriptors.ts</files>
  <action>
Enhance the searchDescriptors function from 03-01 to return pagination metadata.

BREAKING CHANGE: The return type changes from `SearchResult[]` to `SearchResponse`. All callers must be updated to access `.results` property.

1. Add a SearchResponse interface that includes:
   - results: SearchResult[]
   - total: number (total matching results, not just current page)
   - page: number (current page, 1-indexed)
   - limit: number
   - hasMore: boolean

2. Update SearchParams to use page instead of offset:
   - page?: number (default 1)
   - limit?: number (default 20)

3. Execute two queries in parallel:
   - Results query with ORDER BY and LIMIT/OFFSET
   - Count query for total (without LIMIT)

4. Use Promise.all for parallel execution:
```typescript
const [results, countResult] = await Promise.all([
  prisma.$queryRaw<SearchResult[]>(...resultsQuery),
  prisma.$queryRaw<[{ count: number }]>(...countQuery),
]);
```

5. Calculate pagination metadata:
```typescript
const total = countResult[0].count;
const hasMore = page * limit < total;
```

6. Limit maximum page to prevent deep pagination performance issues:
   - If page > 20 (400 results), return empty results with warning
   - Or clamp page to max 20 silently

Key implementation:
- The count query should use `COUNT(*)::int` to avoid BigInt issues
- Use the same WHERE clause for both queries (consistency)
- Calculate offset as (page - 1) * limit
  </action>
  <verify>
Create test script `scripts/test-pagination.ts`:
```typescript
import { searchDescriptors } from "../src/lib/search-descriptors";

async function test() {
  const page1 = await searchDescriptors({ query: "safety", page: 1, limit: 5 });
  const page2 = await searchDescriptors({ query: "safety", page: 2, limit: 5 });

  console.log("Page 1:", page1.results.length, "total:", page1.total, "hasMore:", page1.hasMore);
  console.log("Page 2:", page2.results.length, "ids differ:", page1.results[0]?.id !== page2.results[0]?.id);

  if (page1.hasMore && page1.results[0]?.id !== page2.results[0]?.id) {
    console.log("✓ Pagination works correctly");
  } else {
    console.log("✗ Pagination test failed");
    process.exit(1);
  }
}

test().catch(console.error);
```

Run: `npx ts-node scripts/test-pagination.ts`
  </verify>
  <done>searchDescriptors returns SearchResponse with total count, page number, hasMore flag, parallel query execution</done>
</task>

<task type="auto">
  <name>Task 2: Create facet counts query function</name>
  <files>src/lib/queries/facet-counts.ts</files>
  <action>
Create `src/lib/queries/facet-counts.ts` for dynamic filter panel counts:

```typescript
import { prisma } from "@/lib/prisma";
import { Prisma } from "@prisma/client";

export interface FacetCount {
  name: string;
  count: number;
}

export interface Facets {
  skillAreas: FacetCount[];
  categories: FacetCount[];
  qualities: FacetCount[];
}

/**
 * Get facet counts for filter panels.
 * When searchQuery is provided, counts reflect matching descriptors only.
 * When empty, counts reflect all non-deleted descriptors.
 */
export async function getFacetCounts(searchQuery?: string): Promise<Facets> {
  // Build the FTS condition if query provided
  const ftsCondition = searchQuery
    ? Prisma.sql`
        websearch_to_tsquery('english', ${searchQuery}) @@ (
          setweight(to_tsvector('english', coalesce("criterionName", '')), 'A') ||
          setweight(to_tsvector('english', coalesce("excellent", '')), 'B') ||
          setweight(to_tsvector('english', coalesce("good", '')), 'B') ||
          setweight(to_tsvector('english', coalesce("pass", '')), 'B') ||
          setweight(to_tsvector('english', coalesce("belowPass", '')), 'B')
        ) AND
      `
    : Prisma.sql``;

  // Execute all facet queries in parallel
  const [skillAreas, categories, qualities] = await Promise.all([
    prisma.$queryRaw<FacetCount[]>`
      SELECT "skillName" as name, COUNT(*)::int as count
      FROM "Descriptor"
      WHERE ${ftsCondition} "deletedAt" IS NULL
      GROUP BY "skillName"
      ORDER BY count DESC, name ASC
    `,
    prisma.$queryRaw<FacetCount[]>`
      SELECT category as name, COUNT(*)::int as count
      FROM "Descriptor"
      WHERE ${ftsCondition} "deletedAt" IS NULL AND category IS NOT NULL
      GROUP BY category
      ORDER BY count DESC, name ASC
    `,
    prisma.$queryRaw<FacetCount[]>`
      SELECT "qualityIndicator" as name, COUNT(*)::int as count
      FROM "Descriptor"
      WHERE ${ftsCondition} "deletedAt" IS NULL
      GROUP BY "qualityIndicator"
      ORDER BY count DESC
    `,
  ]);

  return { skillAreas, categories, qualities };
}
```

Key implementation notes:
- Uses same FTS expression as searchDescriptors (must match exactly for index use)
- Parallel queries with Promise.all for performance
- ::int cast on COUNT to avoid BigInt serialization issues
- Filters out NULL categories in the GROUP BY query
- Orders by count DESC so most common values appear first
- The empty Prisma.sql`` is valid and produces no SQL when no query
  </action>
  <verify>
Create test script `scripts/test-facets.ts`:
```typescript
import { getFacetCounts } from "../src/lib/queries/facet-counts";

async function test() {
  const allFacets = await getFacetCounts();
  console.log("All skills:", allFacets.skillAreas.slice(0, 3));

  const safetyFacets = await getFacetCounts("safety");
  console.log("Safety-filtered skills:", safetyFacets.skillAreas.slice(0, 3));

  const allTotal = allFacets.skillAreas.reduce((sum, f) => sum + f.count, 0);
  const safetyTotal = safetyFacets.skillAreas.reduce((sum, f) => sum + f.count, 0);
  console.log("Filtering works:", safetyTotal < allTotal);

  if (safetyTotal < allTotal) {
    console.log("✓ Facet counts work correctly");
  } else {
    console.log("✗ Facet filtering test failed");
    process.exit(1);
  }
}

test().catch(console.error);
```

Run: `npx ts-node scripts/test-facets.ts`
  </verify>
  <done>getFacetCounts returns skill area, category, and quality counts; counts update based on search query</done>
</task>

<task type="auto">
  <name>Task 3: Verify filters combine with search correctly and performance meets SEARCH-05 requirement</name>
  <files>scripts/test-pagination-facets.ts</files>
  <action>
Create a comprehensive test script at `scripts/test-pagination-facets.ts` that:

1. Tests that applying filters narrows search results (AND combination) rather than replacing them
2. Verifies SEARCH-05 performance requirement: combined pagination + facets in <100ms

```typescript
import { searchDescriptors } from "../src/lib/search-descriptors";
import { getFacetCounts } from "../src/lib/queries/facet-counts";

async function testFilterCombination() {
  console.log("=== Testing Filter Combination ===\n");

  // Search only
  const searchOnly = await searchDescriptors({ query: "safety", limit: 100 });
  console.log("Search only:", searchOnly.total);

  // Get a skill that has safety results
  const skillsWithSafety = [...new Set(searchOnly.results.map(r => r.skillName))];
  const testSkill = skillsWithSafety[0];
  console.log("Testing with skill:", testSkill);

  // Search + filter
  const filtered = await searchDescriptors({
    query: "safety",
    skillName: testSkill,
    limit: 100
  });
  console.log("With skill filter:", filtered.total);

  // Verify: filtered count should be less than or equal to search-only
  const filterNarrows = filtered.total <= searchOnly.total;
  console.log("Filter narrows results:", filterNarrows);

  // Verify: all filtered results have the skill
  const allMatchSkill = filtered.results.every(r => r.skillName === testSkill);
  console.log("All results match skill:", allMatchSkill);

  // Verify: search still active (results are ranked)
  const hasRank = filtered.results.every(r => r.rank !== null);
  console.log("Results still ranked:", hasRank);

  return filterNarrows && allMatchSkill && hasRank;
}

async function testPerformance() {
  console.log("\n=== Testing SEARCH-05 Performance (<100ms) ===\n");

  const queries = ["safety", "teamwork", "precision", "quality"];
  let allPassed = true;

  for (const q of queries) {
    const start = Date.now();

    // Run both queries in parallel (as the real page does)
    const [searchResponse, facets] = await Promise.all([
      searchDescriptors({ query: q, page: 1, limit: 20 }),
      getFacetCounts(q),
    ]);

    const duration = Date.now() - start;
    const passed = duration < 100;

    console.log(
      `Query '${q}': ${searchResponse.total} results, ` +
      `${facets.skillAreas.length} skills, ` +
      `${duration}ms ${passed ? "✓" : "✗ EXCEEDED 100ms"}`
    );

    if (!passed) allPassed = false;
  }

  return allPassed;
}

async function main() {
  const filterTestPassed = await testFilterCombination();
  const perfTestPassed = await testPerformance();

  console.log("\n=== Summary ===");
  console.log("Filter combination:", filterTestPassed ? "✓ PASSED" : "✗ FAILED");
  console.log("Performance (<100ms):", perfTestPassed ? "✓ PASSED" : "✗ FAILED");

  if (!filterTestPassed || !perfTestPassed) {
    process.exit(1);
  }
}

main().catch((err) => {
  console.error("Test failed:", err);
  process.exit(1);
});
```

Run: `npx ts-node scripts/test-pagination-facets.ts`

Expected output:
- Filter narrows results: true
- All results match skill: true
- Results still ranked: true
- All queries complete combined pagination + facets in <100ms
  </action>
  <verify>
Run `npx ts-node scripts/test-pagination-facets.ts` - all tests pass, all queries <100ms.
  </verify>
  <done>Filters confirmed to narrow search results (AND combination), search relevance ranking preserved when filters applied, SEARCH-05 performance requirement verified</done>
</task>

</tasks>

<verification>
1. Pagination works: Different pages return different results
2. Total count accurate: Matches manual count of all matching results
3. Facet counts update: Counts decrease when search query applied
4. Filters combine: Search + filter returns fewer results than search alone
5. SEARCH-05 Performance: Combined pagination + facets complete in <100ms
6. TypeScript compiles: `npx tsc --noEmit`
</verification>

<success_criteria>
- searchDescriptors returns pagination metadata (total, page, hasMore)
- getFacetCounts returns counts per skill area, category, quality
- Facet counts update dynamically based on search query
- Filters narrow search (AND), do not replace
- Combined pagination + facets performance verified at <100ms (SEARCH-05)
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-discovery/03-03-SUMMARY.md`
</output>
