---
phase: 03-search-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/migrations/YYYYMMDDHHMMSS_add_fts_indexes/migration.sql
  - src/lib/search-descriptors.ts
  - scripts/test-search.ts
autonomous: true

must_haves:
  truths:
    - "Keyword search returns results ranked by relevance"
    - "Search completes in under 100ms for typical queries"
    - "Search works across criterionName and all performance level fields"
    - "Search returns relevant results for user queries"
  artifacts:
    - path: "prisma/migrations/*/migration.sql"
      provides: "Functional GIN index for full-text search"
      contains: "CREATE INDEX idx_descriptors_fts"
    - path: "src/lib/search-descriptors.ts"
      provides: "Full-text search function with relevance ranking"
      exports: ["searchDescriptors"]
      min_lines: 50
  key_links:
    - from: "src/lib/search-descriptors.ts"
      to: "prisma.$queryRaw"
      via: "PostgreSQL FTS query with ts_rank_cd"
      pattern: "ts_rank_cd.*websearch_to_tsquery"
---

<objective>
Create PostgreSQL full-text search infrastructure with GIN indexes and relevance-ranked search function

Purpose: Enable fast, relevant keyword search across the 12K+ descriptor corpus with <100ms performance target
Output: Migration with functional GIN index, search query function using $queryRaw with websearch_to_tsquery
</objective>

<execution_context>
@C:\Users\LukeBoustridge\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\LukeBoustridge\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search-discovery/03-RESEARCH.md

# Prior work reference
@.planning/phases/02-admin-curation/02-01-SUMMARY.md (pg_trgm extension already enabled)
@src/lib/descriptors.ts (existing query patterns)
@src/lib/duplicate-detection.ts (existing $queryRaw patterns)
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create functional GIN index migration for full-text search</name>
  <files>prisma/migrations/YYYYMMDDHHMMSS_add_fts_indexes/migration.sql</files>
  <action>
Create a new Prisma migration that adds a functional GIN index for weighted full-text search:

1. Run `npx prisma migrate dev --create-only --name add_fts_indexes` to create empty migration
2. Add the following SQL to the migration file:

```sql
-- Functional GIN index for weighted full-text search
-- A-weight (1.0) for criterionName = most important
-- B-weight (0.4) for performance levels = secondary importance
CREATE INDEX idx_descriptors_fts
ON "Descriptor"
USING GIN (
  setweight(to_tsvector('english', coalesce("criterionName", '')), 'A') ||
  setweight(to_tsvector('english', coalesce("excellent", '')), 'B') ||
  setweight(to_tsvector('english', coalesce("good", '')), 'B') ||
  setweight(to_tsvector('english', coalesce("pass", '')), 'B') ||
  setweight(to_tsvector('english', coalesce("belowPass", '')), 'B')
);

-- Partial B-tree indexes for filter columns (only non-deleted rows)
CREATE INDEX idx_descriptors_skill_name_active ON "Descriptor"("skillName") WHERE "deletedAt" IS NULL;
CREATE INDEX idx_descriptors_category_active ON "Descriptor"("category") WHERE "deletedAt" IS NULL;
CREATE INDEX idx_descriptors_quality_active ON "Descriptor"("qualityIndicator") WHERE "deletedAt" IS NULL;
```

3. Apply migration with `npx prisma migrate dev`

IMPORTANT:
- Use functional index (not stored tsvector column) - same performance, no storage overhead
- The pg_trgm extension is already enabled from Phase 2 migration (02-01)
- Use 'english' dictionary for stemming and stop word removal
- Coalesce NULL fields to empty string to prevent NULL propagation
  </action>
  <verify>
Run `npx prisma migrate status` - should show migration applied successfully.
Run database query to verify index exists:
`npx prisma db execute --stdin <<< "SELECT indexname FROM pg_indexes WHERE tablename = 'Descriptor' AND indexname = 'idx_descriptors_fts';"`
  </verify>
  <done>GIN index for FTS created, partial B-tree indexes for filters created, migration applied without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create full-text search function with relevance ranking</name>
  <files>src/lib/search-descriptors.ts, scripts/test-search.ts</files>
  <action>
Create new file `src/lib/search-descriptors.ts` with a search function that:

1. Uses `websearch_to_tsquery` for user-friendly query parsing (supports quotes, OR, NOT)
2. Matches against the weighted tsvector expression (same as index)
3. Ranks results with `ts_rank_cd` using normalization option 32 (length-adjusted)
4. Combines FTS with optional filters (skillName, category, qualityIndicator) using AND
5. Supports pagination with limit/offset
6. Returns results with rank score for debugging/display

Structure:
```typescript
import { prisma } from "@/lib/prisma";
import { Prisma, QualityIndicator } from "@prisma/client";

export interface SearchParams {
  query?: string;
  skillName?: string;
  category?: string;
  qualityIndicator?: QualityIndicator;
  limit?: number;
  offset?: number;
}

export interface SearchResult {
  id: string;
  code: string;
  criterionName: string;
  excellent: string | null;
  good: string | null;
  pass: string | null;
  belowPass: string | null;
  skillName: string;
  sector: string | null;
  category: string | null;
  tags: string[];
  qualityIndicator: QualityIndicator;
  rank: number | null;
}

export async function searchDescriptors(params: SearchParams): Promise<SearchResult[]> {
  // Build dynamic WHERE conditions
  // If query provided: use FTS match with rank ordering
  // If no query: order by criterionName ASC
  // Always exclude soft-deleted (deletedAt IS NULL)
  // Combine filters with AND
}
```

Key implementation details:
- Use `Prisma.sql` template literals for safe parameterization
- Build WHERE clause dynamically based on provided filters
- The tsvector expression in query MUST match the index expression exactly
- Use `::int` cast for counts to avoid BigInt issues in Node.js
- Return rank as null when no query provided (browsing mode)

Reference the pattern from 03-RESEARCH.md Pattern 2 for the exact SQL structure.

Then create a standalone test script `scripts/test-search.ts`:
```typescript
import { searchDescriptors } from "../src/lib/search-descriptors";

async function test() {
  console.log("Testing searchDescriptors function...\n");

  const results = await searchDescriptors({ query: "safety", limit: 5 });
  console.log("Results count:", results.length);
  console.log("First result rank:", results[0]?.rank);
  console.log("First result criterion:", results[0]?.criterionName);

  if (results.length > 0 && results[0].rank !== null) {
    console.log("\n✓ Search returns ranked results");
  } else {
    console.log("\n✗ Search did not return ranked results");
    process.exit(1);
  }
}

test().catch((err) => {
  console.error("Test failed:", err);
  process.exit(1);
});
```
  </action>
  <verify>
Run the test script: `npx ts-node scripts/test-search.ts`
Should output results count, rank value, and success message.
  </verify>
  <done>searchDescriptors function returns relevance-ranked results for keyword queries, handles empty query gracefully, combines with filters using AND</done>
</task>

<task type="auto">
  <name>Task 3: Verify search performance meets <100ms target</name>
  <files>None (verification only)</files>
  <action>
Test search performance with realistic queries against the 12K+ descriptor corpus.

Create a benchmark script at `scripts/benchmark-search.ts`:
```typescript
import { searchDescriptors } from "../src/lib/search-descriptors";

async function benchmark() {
  const queries = ["safety", "teamwork", "precision measurement", "quality control"];

  for (const q of queries) {
    const start = Date.now();
    const results = await searchDescriptors({ query: q, limit: 20 });
    const duration = Date.now() - start;
    console.log(`Query '${q}': ${results.length} results in ${duration}ms`);

    if (duration > 100) {
      console.warn(`⚠ Query exceeded 100ms target`);
    }
  }
}

benchmark().catch(console.error);
```

Run: `npx ts-node scripts/benchmark-search.ts`

If any query exceeds 100ms, check that the GIN index is being used:
```sql
EXPLAIN ANALYZE
SELECT id, ts_rank_cd(...) as rank
FROM "Descriptor"
WHERE websearch_to_tsquery('english', 'safety') @@ (...)
ORDER BY rank DESC
LIMIT 20;
```

The plan should show "Bitmap Heap Scan" with "Bitmap Index Scan on idx_descriptors_fts", NOT "Seq Scan".

Document performance results in the summary.
  </action>
  <verify>
All test queries complete in <100ms. EXPLAIN shows index usage.
  </verify>
  <done>Search performance verified at <100ms for typical queries, GIN index confirmed in use via EXPLAIN</done>
</task>

</tasks>

<verification>
1. Migration applied successfully: `npx prisma migrate status`
2. GIN index exists: Query pg_indexes for idx_descriptors_fts
3. Search function works: `npx ts-node scripts/test-search.ts` passes
4. Filters combine with search: `searchDescriptors({ query: 'safety', skillName: 'Welding' })` narrows results
5. Performance target met: All queries <100ms
</verification>

<success_criteria>
- FTS GIN index created and applied via migration
- searchDescriptors function returns relevance-ranked results
- Query performance verified at <100ms
- Filters narrow search results (AND combination, not replacement)
- Index usage confirmed via EXPLAIN
</success_criteria>

<output>
After completion, create `.planning/phases/03-search-discovery/03-01-SUMMARY.md`
</output>
